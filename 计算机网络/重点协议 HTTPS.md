# Https

**HTTPS = HTTP+加密+认证+完整性保护**

HTTPS就是身披SSL外壳的HTTP

![image-20200610154226262](C:\Users\apple\AppData\Roaming\Typora\typora-user-images\image-20200610154226262.png)

**SSL(Security Socket Layer,安全套接层)**

* 为网络通信提供安全及数据完整性的一种安全协议
* 是操作系统对外的API，SSL3.0后更名为TLS
* 采用**身份验证**和** **保证网络通信的安全和数据的完整性。

### HTTP为什么不安全？

* http协议属于明文传输协议，交互过程以及数据传输都没有进行加密，通信双方也没有进行任何认证，通信过程非常容易遭遇劫持、监听、修改，会造成严重的流量劫持等问题。
* 可以把http通信比喻成寄送信件一样，A给B寄信，信件在寄送过程中，会经过很多的邮递员之手，他们可以拆开信读取里面的内容(http是明文传输的)。A的信件里面的任何内容(包括各类账号和密码)都会被轻易窃取。除此以外，邮递员们还可以伪造或者修改信件的内容，导致B接收到的信件内容是假的。
* 比如常见的，在http通信过程中，“中间人”将广告链接嵌入到服务器发给用户的http报文里，导致用户界面出现很多不良链接；或者是修改用户的请求URL，导致用户的请求被劫持到另外一个网络，用户的请求永远到不了真正的服务器。这些都会导致用户得不到正确的服务，甚至是损失惨重。

### HTTPS如何保证安全？

* 要引入**加密以及身份验证机制**

* 如果服务器给客户端的消息是密文的，只有服务器和客户端才能读懂，就可以保证数据的保密性。同时，在交换数据之前，验证一下对方的合法身份，就可以保证通信双方的安全。那么，问题来了，服务器 把数据加密后，客户端是如何读懂这些数据尼？这时服务器必须要把加密的秘钥(对称秘钥)告诉给客户端，客户端才能利用对称密钥解开密文的内容。**但是，服务器如果将这个对称密钥以明文的方式给客户端，还是会被中间人截获，中间人也会知道对称密钥，依然无法保证通信的保密性。但是，如果服务器以密文的方式将对称密钥发给客户端，客户端又如何解开这个密文，得到其中的对称密钥呢？**

  说到这里，大家是不是有点儿糊涂了？一会儿密钥，一会儿对称密钥，都有点儿被搞晕的节奏。在这里，提前给大家普及一下，这里的密钥，指的是非对称加解密的密钥，是用于TLS握手阶段的； 对称密钥，指的是对称加解密的密钥，是用于后续传输数据加解密的。下面将详细说明。

  **这时，我们引入了非对称加解密的概念。****在非对称加解密算法里，公钥加密的数据，有且只有唯一的私钥才能够解密**，所以服务器只要把公钥发给客户端，客户端就可以用这个公钥来加密进行数据传输的对称密钥。客户端利用公钥将对称密钥发给服务器时，即使中间人截取了信息，也无法解密，**因为私钥只部署在服务器，其他任何人都没有私钥，因此，只有服务器才能够解密。**服务器拿到客户端的信息并用私钥解密之后，就可以拿到加解密数据用的对称密钥，通过这个对称密钥来进行后续通信的数据加解密。除此之外，非对称加密可以很好的管理对称密钥，保证每次数据加密的对称密钥都是不相同的，这样子的话，即使客户端病毒拉取到通信缓存信息，也无法窃取正常通信内容。

  上述通信过程，可以画成以下交互图：

  ![image-20200610165638627](C:\Users\apple\AppData\Roaming\Typora\typora-user-images\image-20200610165638627.png)

  但是这样似乎还不够，如果通信过程中，在三次握手或者客户端发起HTTP请求过程中，客户端的请求被中间人劫持，那么中间人就可以伪装成“假冒客户端”和服务器通信；中间人又可以伪装成“假冒服务器”和客户端通信。接下来，我们详细阐述中间人获取对称密钥的过程：

  中间人在收到服务器发送给客户端的公钥（这里是“正确的公钥”）后，并没有发给客户端，而是中间人将自己的公钥（这里中间人也会有一对公钥和私钥，这里称呼为“伪造公钥”）发给客户端。之后，客户端把对称密钥用这个“伪造公钥”加密后，发送过程中经过了中间人，中间人就可以用自己的私钥解密数据并拿到对称密钥，此时中间人再把对称密钥用“正确的公钥”加密发回给服务器。此时，客户端、中间人、服务器都拥有了一样的对称密钥，后续客户端和服务器的所有加密数据，中间人都可以通过对称密钥解密出来。

  中间人获取对称密钥的过程如下：

  ![image-20200610165718567](C:\Users\apple\AppData\Roaming\Typora\typora-user-images\image-20200610165718567.png)

  为了解决此问题，我们引入了数字证书的概念。服务器首先生成公私钥，将公钥提供给相关机构（CA），CA将公钥放入数字证书并将数字证书颁布给服务器，此时服务器就不是简单的把公钥给客户端，而是给客户端一个数字证书，数字证书中加入了一些数字签名的机制，保证了数字证书一定是服务器给客户端的。中间人发送的伪造证书，不能够获得CA的认证，此时，客户端和服务器就知道通信被劫持了。加入了CA数字签名认证的SSL会话过程如下所示：

  ![image-20200610165751046](C:\Users\apple\AppData\Roaming\Typora\typora-user-images\image-20200610165751046.png)

  所以综合以上三点：非对称加密算法（**公钥和私钥**）交换对称密钥+数字证书验证身份（**验证公钥是否是伪造的**）+利用**对称密钥**加解密后续传输的数据=**安全**

  ![image-20200610165831476](C:\Users\apple\AppData\Roaming\Typora\typora-user-images\image-20200610165831476.png)

* 加密的方式：

  * 对称加密：加密和解密都使用同一个秘钥
  * 非对称加密：加密使用的密钥和解密使用的秘钥是不相同的
  * 哈希算法：将任意长度的信息转换为固定长度的值，算法不可逆
  * 数字签名：证明某个消息或者文件是某人发出/认同的

* HTTPS数据传输流程

  * 浏览器将支持的加密算法信息发送给服务器
  * 服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器
  * 浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器
  * 服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器
  * 浏览器解密响应消息，并对消息进行验证，之后进行加密交互数据

###  HTTP和HTTPS的区别

* HTTPS需要到CA申请证书，HTTP不需要
* HTTPS密文传输，HTTP明文传输
* HTTPS默认使用443端口，HTTP端口使用80端口
* HTTPS=HTTP+加密+认证+完整性保护，比HTTP安全

