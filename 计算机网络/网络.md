# 网络

**重点知识：**

* 网络分层：OSI七层模型(了解)，TCP/IP四层或五层模型，每一层的代表协议，代表硬件和技术
* 网络传输流程：网络互联(了解)，局域网(了解)，广域网
* 重点协议：
  1. TCP/UDP:掌握特性，原理和流程
  2. HTTP:掌握协议的格式，及作用
  3. 其他重要协议：ARP/RARP , DNS , NAT , NATP , MTU , IMCP ，IP，MAC
  4. 网络传输流程中使用到的技术：以太网，路由，网关+子网掩码

<hr />

## 网络分层-1. TCP/IP五层模型（四层模型没有物理层），从下到上

1. OSI七层模型：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层

2. TCP/IP五层模型：物理层，数据链路层，网络层，传输层，应用层

|            | 代表硬件                   | 协议、技术                          | 特性             |
| ---------- | -------------------------- | ----------------------------------- | ---------------- |
| 物理层     | 双绞线，WiFi电磁波，集线器 |                                     | 发送0,1光电信号  |
| 数据链路层 | 交换机                     | 以太网，令牌环网，无线LAN，ARP，MTU |                  |
| 网络层     | 路由器                     | IP                                  |                  |
| 传输层     |                            | TCP/UDP                             | 主机系统内核实现 |
| 应用层     |                            | HTTP,DNS,NAT,NATP,FTP,SMTP          | 应用程序实现     |

其中**以太网**是用来封装和分用**源MAC和目的MAC**所使用的协议头

**IP协议**是用来封装和分用**源IP和目的IP**所使用的协议头

**TCP/UDP**是用来封装和分用**源端口号和目的端口号**所使用的协议头

**Http**是应用程序协议封装和分用所使用的协议头

<hr />

## 网络分层-2 .封装和分用

* 封装类似发送快速包裹，需要从内往外打包；分用类似拆快递，需要从外往内拆包。
* 使用程序的时候，就知道目的IP+目的端口号

![image-20200412143327691](E:\GitHub\picBed\img\image-20200412143327691.png)

<hr />

## 网络分层-3. MAC和IP地址以及相关概念

* **MAC地址**：也叫物理地址，硬件地址
  * MAC地址用来识别数据链路层中相连的节点;
  * 网卡绑定的物理地址
  * 长度为48位, 及6个字节. 一般用16进制数字加上冒号的形式来表示(例如: 08:00:27:03:fb:19)
  * 在网卡出厂时就确定了, 不能修改. mac地址通常是唯一的(虚拟机中的mac地址不是真实的mac地址, 可能会冲突; 也有些网卡支持用户配置mac地址).
* **IP地址**：IP协议提供一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。由4个数字组成，每个在0~255之间，前三个为网络号，最后一个为主机号
  * 曾经提出一种划分网络号和主机号的方案，把所有IP地址分为五类
    * A类：0.0.0.0到127.255.255.255
    * B类：128.0.0.0到191.255.255.255
    * C类：192.0.0.0到223.255.255.255
    * D类：224.0.0.0到239.255.255.255
    * E类：240.0.0.0到247.255.255.255
  * 公有地址
    * 公有地址由Inter NIC负责，这些IP地址分配给注册并向Inter NIC提出申请的组织机构。通过它直接访问因特网
  * 私有地址
    * 私有地址属于非注册地址，专门为组织机构内部使用
    * 以下留出的内部私有地址
      * A类：10.0.0.0~10.255.255.255
      * B类：172.16.0.0~172.31.255.255
      * C类：192.168.0.0~192.168.255.255
* **IP和MAC的区别：**
  * IP地址描述的是路途总体的起点和终点
  * MAC地址描述的是路途上的每一个区间的起点和终点
  * 网络设备进行数据传输，硬件是通过MAC地址来发送数据包
* **网段：**网络号相同
* **局域网**：在私网地址范围内，并且能ping通，不管网段是否相同
* **五元组**：**"源IP"**+**"源端口号**+**"目的IP"**+**"目的端口号"**+**"协议号"**
* **端口号**：绑定主机中某一个应用程序，应用程序都是通过**在传输层包装**端口号**发生/接收数据**
  * 0 - 1023: 知名端口号, HTTP, FTP, SSH等这些广为使用的应用层协议, 他们的端口号都是固定的.
    * ssh服务器, 使用22端口
    * ftp服务器, 使用21端口
    * telnet服务器, 使用23端口
    * http服务器, 使用80端口
    * https服务器, 使用443
  * 1024 - 65535: 操作系统动态分配的端口号. 客户端程序的端口号, 就是由操作系统从这个范围分配的.
* **IP+端口号**：可以定位到网络上具体的某一应用程序
* **发送数据**：五元组
* **接收端响应数据**：目的IP+目的端口号 = 发送数据包中的源IP+源端口

<hr />

## 网络分层-4. 网络设备的功能

* 对于一台**主机**，它的操作系统内核实现了从传输层到物理层的内容
  * 发送数据报：程序发送数据报的时候，就知道五元组的信息（**"源IP"**+**"源端口号**+**"目的IP"**+**"目的端口号"**+**"协议号"**）
    1. **DNS协议**：域名转换为IP
       * 本机缓存中查找：C：\Windows\System32\drivers\etc\hosts
       * 本机找不到，往上一级的设备/DNS服务器查，最终在全球顶级域名服务器中查询，如果还是没有，就是没有该域名
    2. 系统封装分用物理层到传输层的数据报头
  * **ARP缓存表**：主机和路由器
    * IP地址和MAC地址的映射表：通过IP查MAC
  * 网络跳转在每一跳在接收/发送时，是否需要修改源MAC/目的MAC，路由器和主机是需要的，集线器和交换机不需要
* 对于一台**路由器**，它实现了从网络层到物理层
  * WAN提供公网IP端口，连接公网上的网络设备
  * LAN提供私网IP端口，相连局域网内的设备
  * IP地址：WAN口使用公网IP，LAN使用私网IP
* 对于一台**交换机**，它实现了数据链路层到物理层
  * 功能：只是转发数据报，根据数据包中目的MAC来转发
  * 原理：内含MAC地址表：建立MAC地址和端口映射。（此处的端口是物理意义上的，用来连接主机）
* 对于**集线器**，只实现了物理层
  * 功能：只是转发数据报，广播发送到其他所有主机

<hr />

## 网络数据传输流程-1.网络互联（集线器）

* 集线器的作用：只做数据的转发
* ARP协议：建立IP与MAC的映射主机ARP缓存表
* ![image-20200412160531944](E:\GitHub\picBed\img\image-20200412160531944.png)
* 场景：主机A发送FTP”下载某个文件”数据包------>主机C
* 查找目的主机MAC地址：
  1. 查找本地ARP缓存表，通过目的IP查找目的MAC
     1. 如果找到，就直接发送数据包**（广播）**
     2. 如果找不到，主机A广播一个ARP请求数据包---->所有主机接收到ARP数据包
        * ARP请求数据包：源MAC+目的MAC（广播形式的FF:FF：...），目的IP
        * 其他主机接收到ARP数据包的处理过程：
        * if(目的ip==自己的ip) 响应回自己的MAC； else 丢弃数据包
  2. 更新本机ARP缓存表
  3. 发送FTP请求数据：（目的MAC：主机MAC）
     * 集线器转发数据报到其他所有主机；if(目的MAC==自己)处理 ；else丢弃；
* 冲突域：
  * 概念：连接同一导线上的所有工作站的集合，或者说是同一物理网段上所有节点的集合或以太网上竞争同一宽带的节点集合。（房间中所有人同时说话，会让大家互相都听不清）
  * 集线器网络互联存在冲突域，交换机可以解决冲突域。

## 网络数据传输流程-2. 局域网

* 局域网可以是同网段，可以是不同网段
* 同网段：网百络中同一网段指的是IP地址和子网掩码相与得到相同的网络地址。

#### 2.1交换机连接

* 交换机连接：交换机没有进行数据的加工(封装和分用)
* ![image-20200413135013604](C:\Users\apple\AppData\Roaming\Typora\typora-user-images\image-20200413135013604.png)
  1. 本机封装
  2. 查找本地ARP缓存表，通过目的IP查找目的MAC；
     1. 如果找到，就直接发送数据包
     2. 如果本机ARP缓存表找不到目的MAC-->发送ARP请求的广播数据包--->交换机转发--->类似网络互联的查询IP主机MAC的过程
  3. 发送数据包 --- > 交换机查询目的的MAC --- > 通过MAC地址转换表，知道要发送数据到哪个端口 --- > 通过端口发送对应主机

#### 2.2 交换机+路由器

* ![image-20200413135732402](C:\Users\apple\AppData\Roaming\Typora\typora-user-images\image-20200413135732402.png)
* 场景：主机1发送FTP“某文件下载”数据包到主机4
* 发送的数据报：源IP+源MAC+源端口号+目的IP+目的MAC+目的端口号+协议号
* 发送过程：
  1. 判断是否本机与目的主机在同一个网段：目的IP+子网掩码 位与操作得到网络号
     1. 在同一个网段，走交换机连接的逻辑
     2. 在不同网段：通过ARP缓存表，查询网关IP对应的MAC
        1. 主机发送数据报为：**源IP+源MAC+源端口号+目的IP+目的MAC+目的端口号+协议号**
        2. 路由器接受数据报：
           1. 路由器：目的IP对应 设备的 MAC地址 同之前ARP缓存查询的过程相同
           2. 数据报的加工(先分用，在重新封装)
              * 数据包的以太网帧(数据链路层)里边包含的源MAC修改为自己(路由器)的MAC，目的MAC修改为目的主机(主机4)的MAC
           3. 按目的MAC发数据报：发送到主机4
           4. 目的主机解析(分用)，响应数据报(封装发送)，和之前发送端的逻辑一样

## 网络数据传输流程-3. 广域网（重点）

* ![image-20200413141230328](C:\Users\apple\AppData\Roaming\Typora\typora-user-images\image-20200413141230328.png)

* 场景：主机1请求https://www.baidu.com/  

  * https: 协议号
  * www.baidu.com : 域名

* 传输流程：

  1. 通过域名查询对应的IP地址：DNS协议（本地DNS缓存-->路由器--->上级DNS服务器......-->全球顶级DNS服务器）

  2. 封装数据报：得到五元组信息

     ![image-20200413141500218](C:\Users\apple\AppData\Roaming\Typora\typora-user-images\image-20200413141500218.png)

  3. 目的IP网络号+子网掩码相与得到一个网络号，与本机网络号对比，判断出不在一个网段

  4. 发送数据报到路由器：

     * 源MAC：主机1的MAC ； 目的MAC：路由器的MAC；源IP：主机1的局域网IP；目的IP：百度服务器IP；协议号

  5. 路由器处理数据：

     * 路由器可能没有百度服务器MAC，下一跳的目的MAC怎么办？

       ​	百度服务器接收数据时，返回响应数据时，需要根据现在发送数据报中的源IP+源端口号来返回。使用局域网IP+port有问题

     * 路由器根据它的路由表决定下一跳地址
       * 路由：我（路由器）也不知道百度在哪（目的IP），但是通过路由功能，知道方向，可以知道最优的下一站设备的MAC
       * NAT+NAPT：局域网主机源IP+源port，修改为路由器公网IP+公网的映射端口（程序端口）
       * 修改：源MAC修改为目的MAC，目的MAC修改为下一跳设备的MAC

  6. 下一跳设备处理数据：只修改MAC为自己的MAC,目的MAC为再下一跳设备的MAC（目的IP！=自己）

  7. 百度服务器接收数据：目的MAC是自己的，需要处理，目的IP==自己，接收数据报(分用)

  8. 返回数据报：源IP：百度服务器IP，源端口号：百度http程序端口；目的IP：路由器的公网IP。目的端口：路由器程序端口

  9. 路由器接收响应数据报：目的IP--->局域网主机1的IP，目的端口：主机1的浏览器程序端口，目的MAC：主机1的MAC

  10. 主机1接收处理响应数据报：if(目的MAC == 我自己的)处理 --- >(if目的IP==自己的) -->分用给程序

      * 说明：每一跳的过程中经过的设备，都先判断mac，然后发现ip不是自己的，所以交给后边设备，最后目的地拿到数据也是这样，但发现目的ip是我，所以就自己处理数据

      ![image-20200418155753148](E:\GitHub\picBed\img\image-20200418155753148.png)

## 重点协议-1.UDP

![image-20200419211435355](C:\Users\apple\AppData\Roaming\Typora\typora-user-images\image-20200419211435355.png)

16位UDP长度，表示数据报(UDP首部+UDP数据)的最大长度。

如果校验和出错，就会直接丢弃

* **特点**：不安全但是效率高
  * 无连接
  * 不可靠：没有确定应答机制，没有超时重传机制，也没有连接管理机制
  * 面向数据报：最大发送64k
    * 应用层交给UDP多长的报文, UDP原样发送, 既不会拆分, 也不会合并;、
    * 用UDP传输100个字节的数据:
      * 如果发送端调用一次sendto, 发送100个字节, 那么接收端也必须调用对应的一次recvfrom, 接收100个字节; 而不能循环调用10次recvfrom, 每次接收10个字节;
  * UDP没有发送缓冲区，只有接收缓冲区：
    * UDP没有真正意义上的 发送缓冲区. 调用sendto会直接交给内核, 由内核将数据传给网络层协议进行后续的传输动作;
    * UDP具有接收缓冲区. 但是这个接收缓冲区不能保证收到的UDP报的顺序和发送UDP报的顺序一致; 如果缓冲区满了, 再到达的UDP数据就会被丢弃;
* **基于UDP的应用层协议:**
  * NFS: 网络文件系统
  * TFTP: 简单文件传输协议
  * DHCP: 动态主机配置协议
  * BOOTP: 启动协议(用于无盘设备启动)
  * DNS: 域名解析协议

## 重点协议-2. TCP

* 协议格式：

  ![image-20200419214643600](C:\Users\apple\AppData\Roaming\Typora\typora-user-images\image-20200419214643600.png)

  * 源/目的端口号：从那个进程来，到那个进程去；
  * 32位序号/32位确定号：和 TCP 的 ACK 机制有关，发送端给数据进行编号，接收端收到数据后确认收到哪些编号的数据。
  * 4位TCP报头长度：表示该TCP头部有多少个32位bit（有4个字节）；所以TCP头部最大长度是15*4=60
  * 6位标志位：
    * URG:紧急指针是否有效
    * **ACK:**确认号是否有效
    * PSH:提示接收端应用程序立刻从TCP缓冲区把数据读走
    * RST:对方要求重新建立连接; 我们把携带RST标识的称为复位报文段
    * **SYN:**请求建立连接; 我们把携带SYN标识的称为同步报文段
    * **FIN:**通知对方, 本端要关闭了, 我们称携带FIN标识的为结束报文段
  * 16位窗口大小：
  * 16位校验和：发送端填充，CRC 校验，接收端校验不通过，则认为数据有问题。此处的检验和不光包含TCP首部，也包含TCP数据部分。
  * 16紧急指针：略
  * 40字节头部选项：略

* 特点：

  * 有连接
  * 可靠的
  * 面向字节流
  * 具有接收和发送缓冲区

* **确定应答机制(ACK)**:序号+确定序号实现

  * 生活案例理解确定应答机制

    ```
    通常，两个人对话时，在谈话的停顿处可以点头或询问以确认谈话内容。如果对方迟迟没有任何反馈，说话的一方还可以再重复一遍以保证对方确实听到。 因此，对方是否理解了此次对话内容，对方是否完全听到了对话的内容，都要靠对方的反应来判断。网络中的 “确认应答” 就是类似这样的一个概念。当对方听懂对话内容时会说： ＂ 嗯 ＂，这就相当于返回了一个确认应答(ACK)。而当对方没有理解对话内容或没有听清时会问一句 ｀｀ 咦？” 这好比一个否定确认应答
    ```

    ![image-20200419225441783](C:\Users\apple\AppData\Roaming\Typora\typora-user-images\image-20200419225441783.png)

  * TCP将每个字节都进行了编号，既为序列号

  * 每个ACK都带有对应得确认序列号，意思是告诉发送者，我已经收到那些数据；下一次你从什么地方开始

* **超时重传机制：**系统基于TCP协议实现，**动态**计算报文的最大生存时间(MSL),超时时间设置为**2MSL**

  * 作用：超过超时时间，表示丢包(两种情况，如下)，需要重新发送数据报(系统中发送缓冲区保存有数据，可以重发)

  ![image-20200419230335443](C:\Users\apple\AppData\Roaming\Typora\typora-user-images\image-20200419230335443.png)

  * 主机A发送数据给B之后, 可能因为网络拥堵等原因, 数据无法到达主机B;
  * 如果主机A在一个特定时间间隔内没有收到B发来的确认应答, 就会进行重发;、

  但是，主机A未收到B发来的确认应答, 也可能是因为ACK丢失了;

  ​	![image-20200419230522261](C:\Users\apple\AppData\Roaming\Typora\typora-user-images\image-20200419230522261.png)

  

  * 因此主机B会收到很多重复数据. 那么TCP协议需要能够识别出那些包是重复的包, 并且把重复的丢弃掉.
    这时候我们可以利用前面提到的序列号, 就可以很容易做到去重的效果.

* **连接管理机制：**

  * 在正常情况下, TCP要经过**三次握手(红色)建立连接**, **四次挥手(蓝色)断开连接**
  * **！**注意：建立连接都是单方向的连接

  ![image-20200419233249388](C:\Users\apple\AppData\Roaming\Typora\typora-user-images\image-20200419233249388.png)

  * **三次握手**：（建立连接）

    1. 客户端的协议栈向服务器端发送了 SYN 包，并告诉服务器端当前发送序列号 j，客户端进入 SYNC_SENT 状态；
    2. 服务器端的协议栈收到这个包之后，和客户端进行 ACK 应答，应答的值为 j+1，表示对 SYN 包 j 的确认，同时服务器也发送一个 SYN 包，告诉客户端当前我的发送序列号为 k，服务器端进入 SYNC_RCVD 状态；
    3. 客户端协议栈收到 ACK 之后，使得应用程序从 connect 调用返回，表示客户端到服务器端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务器端的 SYN 包进行应答，应答数据为 k+1；
    4. 应答包到达服务器端后，服务器端协议栈使得 accept 阻塞调用返回，这个时候服务器端到客户端的单向连接也建立成功，服务器端也进入 ESTABLISHED 状态。

  * **四次挥手**：（断开连接）

    TCP 连接终止时，主机 1 先发送 FIN 报文，主机 2 进入 CLOSE_WAIT 状态，并发送一个 ACK 应答，同时，主机 2 通过 read 调用获得 EOF，并将此结果通知应用程序进行主动关闭操作，发送 FIN 报文。主机 1 在接收到 FIN 报文后发送 ACK 应答，此时主机 1 进入 TIME_WAIT 状态

    * 为什么要ACK与FIN分开发送？服务器没有继续发FIN包给客户端。
      * 服务器为什么不发FIN，可能是业务实现上的需要，现在不是发送FIN的时机，因为服务器还有数据要发往客户端，发送完了自然就要通过[系统](http://www.2cto.com/os/)调用发FIN了

  * **ClOSE_WAIT状态**：服务端程序没有调用close方法，导致出现大量的连接处于CLOSE_WAIT状态，代表**半关闭**，是一种bug，只需要加上对应的 close 即可解决问题.

    * 关于 "半关闭" , 类似男女朋友分手 

  * **TIME_WAIT状态：**

    * **为啥不能设置为CLOSED?** 因为低4次ACK响应报文时可能丢包，导致服务端无法关闭连接，需要服务器重新发送FIN请求
    * **为啥是2MSL？**返回ACK传输时间+服务端重新发送FIN的传输时间
  
* **滑动窗口：**

  * **窗口大小**指的是无需等待确定应答而可以继续发生数据的最大值。假如窗口为n段
    * 依赖ACK响应报文中的窗口大小字段
    * 依赖拥塞控制窗口大小
  * 收到第一个ACK，滑动窗口向后移动，继续发送第n+1段的数据
  * 操作系统内核为了维护这个滑动窗口，需要开辟**发送缓冲区**来记录当前还有那些数据没有应答；只有确认应答过的数据，才能从缓冲区删掉
  * ACJ响应报文中，携带下一个序号是多少。---->表示在此序号之前的所有数据都已经接收到、
  * **窗口的滑动：**
    * 依赖ACK响应报文中的下一个序号进行滑动，而下一个序号是多少，又依赖接接收到连续报文的最大序号。 

* **流量控制：**

  * 接收端：通过TCP协议头中的“窗口大小”字段，告诉发送端，发送数据的大小。
  * 目的：接收端接收能力有限，为了防止接收缓冲区被打满，再接收数据直接丢弃。使用窗口大小可以告诉发送端发送数据的大小。

* **拥塞控制：**

  * 因为网络上有很多的计算机，可能当前网络状态就已经比较拥堵，在不清楚当前网络状态下，贸然发送大量的数据，是很有可能引起雪上加霜的
  * TCP引入慢启动机制，先发少量的数据探探路，摸清当前网络拥塞状态，再决定按照多大的速度传输数据。
  * 原理：
    * 拥塞窗口初始值设为1，以慢启动指数级增长的方式，达到一定阈值变为线性增长的方式

* **延时应答机制**：
  * 原理：接收到多个数据段时，不针对每条数据报响应ACK，而是延迟一定时间，这样接收缓冲区数据很快被处理，可用空间更大，返回窗口大小字段就可以设置的更大，使网络吞吐量更大，传输效率更高。
* **捎带应答：**
  * 如果服务端也要传输数据到客户端，可以和ACK结合起来一起发送，这就叫捎带应答
* TCP安全机制：
  * 响应应答，超时重传，连接机制，流量控制，拥塞控制
* TCP性能机制：
  * 滑动窗口，延迟应答，捎带应答

# 面试题：

1. 一个进程是否可以bind多个端口号?  

   可以

2. 一个端口号是否可以被多个进程bind?

   不可以

