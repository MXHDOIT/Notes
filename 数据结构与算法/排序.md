# 排序

* <a href="#no1">排序概念</a>
* <a href="#no2">1.插入排序</a>
  * <a href="#no2_1">1.1直接插入排序</a>
  * <a href="#no2_2">1.2希尔排序</a>
* <a href="#no3">2.选择排序</a>
  * <a href="#no3_1">2.1 直接选择排序</a>
  * <a href="#no3_2">2.2 堆排序</a>
* 冒泡排序<a href="#"></a>
* <a href="#no5">快速排序</a>
* 归并排序<a href="#"></a>
* 总结对比<a href="#"></a>

### 排序概念<a id="no1"></a>

* 稳定性：两个相等的数据，经过排序后，如果相对位置没有变化则为**稳定排序**，反之，为不稳定排序。
* 内部排序与外部排序：如果一次性可以将所有数据加载到内存中进行排序则为**内部排序**；反之，为外部排序

### 1.插入排序<a id="no2"></a>

##### 1.1 直接插入排序<a id="no2_1"></a>

* 整个区间被分为：**有序**区间与**无序**区间；

* 原理：每次选择无序区间的第一个元素，在有序区间内选择合适的位置插入。[默认要排序的数据第一个元素是有序的]

* 应用场景：如果搬移元素个数比较少，就比较适合插入排序，序列接近有序或者数据较少时

* 稳定性：稳定

* 时间复杂度：O(n^2)

  * 最优：O(n)  ->  有序时
  * 最差：O(n^2)  ->  逆序

* 空间复杂度：O(1)

* 代码实现：

  ```java
  public static void insertSort(int[] array){
  	
      for(int i = 1; i < array.length;i++){
          //有序区间[0,i)
          //无序区间[i,array.length)
          int num = array[i]; //无序区间第一个数
          int end = i-1; //比较的元素位置
          
          while(end >= 0 && num < array[end]){ //当数组不越界同时当前数比相比较的数小的时候
              array[end+1] = array[end]; //移位
              end--;
          }
          
          //插入元素
          array[end+1] = num;
          
      }
  }
  ```

##### 1.2 希尔排序<a id="no2_2"></a>

* 原理：采用分组的方式，将序列变成：接近有序，将数据变少；[采用直接插入排序对分组后的数据排序]

* 应用场景：元素比较凌乱，个数比较多

* 稳定性：不稳定

* 时间复杂度：O(n^2)

* 空间复杂度：O(n)

* 代码实现：

  ```java
  public static void shellSort(int[] array){
  	int gap = array.length;
      while(gap > 1){
          gap = gap/3+1; //分组数
          for(int i = gap;i < array.length;i++){
              
              int num = array[i]; //分组后当前组中无序的第一个元素
              int end = i - gap;
              
              while(end >= 0 && num < array[end]){
                  array[end+gap] = array[end];
                  end -= gap;
              }
              
              array[end+gap] = num;
          }
      }
  }
  ```

### 2.选择排序<a id="no3"></a>

##### 2.1 直接选择排序<a id="no3_1"></a>

* 原理：每次从无序区间选出最大(或最小)的一个元素，存放在无序区间的最后；直到全部元素排完[n个元素排n-1次]

* 稳定性：不稳定

* 时间复杂度：O(n^2)

* 空间复杂度：O(1)

* 代码实现：

  ```java
  public static void selectSort(int[] array){
  	for(int i = 0;i < array.length-1;i++){
          
          //无序区间：[0,array.length-i）
          //有序区间：[arrar.length-i,array.length)
          int max = 0;
          for(int j = 1; j < array.length-i;j++){
              if(array[j] > array[max]){
                  max = j;
              }
          }
          
          int temp = array[max];
          array[max] = array[array.length-1-i];
          array[array.length-1-i] = temp;
      }
  }
  

  //双向选择排序
   public static void selectSortPlus(int[] array){
          int begin = 0;
          int end = array.length-1;
  
          while(begin < end){
              int min = begin;
              int max = begin;
  
              for (int i = begin+1; i <= end; i++) {
                  if(array[i] < array[min]){
                      min = i;
                  }
                  if(array[i] > array[max]){
                      max = i;
                  }
              }
  
              swap(array,min,begin);
  
              if(max == begin){
                  max = min;
              }
  
              swap(array,max,end);
              begin++;
              end--;
          }
  
      }
  ```
  

##### 2.2 堆排序<a id="no3_2"></a>

* 原理：利用堆这种数据结构;首先建堆，利用堆删除的思想来进行排序(用堆顶元素与堆中最后一个元素进行交换，将堆中元素减少一个，再将堆顶元素向下调整)

* 稳定性：不稳定

* 时间复杂度：O(n*log(n))

* 空间复杂度：O(1)

  ```java
  public satic void headSort(int[] array,int size){  //array排序数组，size数组长度
      creatHeap(array,size);
      
      for(int i = size-1;i >= 0;i--){
          swap(array,i,0); //将最大的节点与最后一个节点交换，以确保排序数组
         	shiftDown(array,size-1,0);//默认斩掉最后一个节点
      }
  }
  
  
  //构建堆
  private static void createHeap(int[] array,int size){
      int parent = (size-2)%2;
      
      for(int i = parent;i >= 0;i--){
          shiftDown(array,size,i);
      }
  }
  
  //向下调整
  public static void shiftDown(int[] array,int size,int index){
      int left = 2*index + 1;
      
      while(left < size){
          int max = left;
          int right = left + 1;
          if(right < size){
              if(array[right] > array[left]){
                  max = right;
              }
          }
          
          if(array[index] >= array[max]){
              break;
          }
          
          int temp = array[index];
          array[index] = array[max];
          array[max] = temp;
          
          index = max;
          left = 2*max+1;
      }
  }
  ```

### 3.冒泡排序

* 原理：
* 稳定性：
* 时间复杂度：

* 空间复杂度：

### 4.快速排序<a id="no5"></a>

* 原理：默认升序

  1. 从区间中取出一个数据作为基准值，按照该基准值将区间分割左右两个部分
  2. 按照快排思想排序左半部分
  3. 按照快排思想排序右半部分

* 应用场景：数据量大比较随机(数据杂乱)

* 稳定性：不稳定

* 时间复杂度：O(n*logn)

* 空间复杂度：O(1)

  ```java
  //交换法
  //quickSort(array,0,array.length);[begin,end)
  public static void quickSort(int[] array,int begin,int end){
      if(end - begin > 1){
          int left = begin;
          int right = end-1;
          int baseNum = array[right];
          
          while(left < right){
              while(left < right && array[left] <= baseNum){
                  left++;
              }
              
              while(left < right && array[right] >= baseNum){
                  right--;
              }
              
              if(left < right){
                  swap(array,left,right);
              }
          }
          
          swap(array,end,left);
          
          quickSort(array,begin,left);
          quickSort(array,left+1,end);
      }
  }
  ```

  

  ```java
  //挖坑法
  //quickSort(array,0,array.length-1);[begin,end]
   public static void quickSort(int[] array,int begin,int end){
          if(begin < end){
              int baseNum = array[begin]; //基数
              int left = begin;
              int right = end;
  
              while(left < right){
                  while(left < end && array[right] >= baseNum){
                      right--;
                  }
  
                  if(left < end){
                      array[left] = array[right];
                  }
  
                  while(left < end && array[left] =< baseNum){
                      left++;
                  }
  
                  if(left < end){
                      array[right] = array[left];
                  }
              }
  
              array[left] = baseNum;
              quickSort(array,begin,left-1);
              quickSort(array,left+1,end);
          }
      }
  ```

  ```java
   //[ left , right):找到比基数小的给前面移动
      public static void quickSort(int[] array,int left,int right){
          if(right - left > 1){
              int cur = left;
              int prev = cur - 1;
              int key = array[right-1];
  
              while(cur < right){
                  if(key > array[cur] && ++prev != cur){  //++prev != cur是因为中间没有比基数大的了不用移动，自排序
                      swap(array,prev,cur);
                  }
                  ++cur;
              }
  
              if(++prev != right-1){
                  swap(array,prev,right-1);
              }
  
              quickSort(array,left,prev);
              quickSort(array,prev+1,right);
          }
      }
  ```



### 5.





