# 排序

* &lt;a href="#id0"&gt;排序概念&lt;/a&gt;
* 1.插入排序&lt;a href="#"&gt;&lt;/a&gt;
  * 1.1直接插入排序&lt;a href="#"&gt;&lt;/a&gt;
  * 1.2希尔排序&lt;a href="#"&gt;&lt;/a&gt;
* 2.选择排序&lt;a href="#"&gt;&lt;/a&gt;
  * 2.1 直接选择排序&lt;a href="#"&gt;&lt;/a&gt;
  * 2.2 堆排序&lt;a href="#"&gt;&lt;/a&gt;
* 冒泡排序&lt;a href="#"&gt;&lt;/a&gt;
* 快速排序&lt;a href="#"&gt;&lt;/a&gt;
* 归并排序&lt;a href="#"&gt;&lt;/a&gt;
* 总结对比&lt;a href="#"&gt;&lt;/a&gt;

### 排序概念

* &lt;a id="id0"&gt;&lt;/a&gt;稳定性：两个相等的数据，经过排序后，如果相对位置没有变化则为**稳定排序**，反之，为不稳定排序。
* 内部排序与外部排序：如果一次性可以将所有数据加载到内存中进行排序则为**内部排序**；反之，为外部排序

### 1.插入排序

##### 1.1 直接插入排序

* 整个区间被分为：**有序**区间与**无序**区间；

* 原理：每次选择无序区间的第一个元素，在有序区间内选择合适的位置插入。[默认要排序的数据第一个元素是有序的]

* 应用场景：如果搬移元素个数比较少，就比较适合插入排序，序列接近有序或者数据较少时

* 稳定性：稳定

* 时间复杂度：O(n^2)

  * 最优：O(n)  ->  有序时
  * 最差：O(n^2)  ->  逆序

* 空间复杂度：O(1)

* 代码实现：

  ```java
  public static void insertSort(int[] array){
  	
      for(int i = 1; i < array.length;i++){
          //有序区间[0,i)
          //无序区间[i,array.length)
          int num = array[i]; //无序区间第一个数
          int end = i-1; //比较的元素位置
          
          while(end >= 0 && num < array[end]){ //当数组不越界同时当前数比相比较的数小的时候
              array[end+1] = array[end]; //移位
              end--;
          }
          
          //插入元素
          array[end+1] = num;
          
      }
  }
  ```

##### 1.2 希尔排序

* 原理：采用分组的方式，将序列变成：接近有序，将数据变少；[采用直接插入排序对分组后的数据排序]

* 应用场景：元素比较凌乱，个数比较多

* 稳定性：不稳定

* 时间复杂度：O(n^2)

* 空间复杂度：O(n)

* 代码实现：

  ```java
  public static void shellSort(int[] array){
  	int gap = array.length;
      while(gap > 1){
          gap = gap/3+1; //分组数
          for(int i = gap;i < array.length;i++){
              
              int num = array[i]; //分组后当前组中无序的第一个元素
              int end = i - gap;
              
              while(end >= 0 && num < array[end]){
                  array[end+gap] = array[end];
                  end -= gap;
              }
              
              array[end+gap] = num;
          }
      }
  }
  ```

### 2.选择排序

##### 2.1 直接选择排序

* 原理：每次从无序区间选出最大(或最小)的一个元素，存放在无序区间的最后；直到全部元素排完[n个元素排n-1次]

* 稳定性：不稳定

* 时间复杂度：O(n^2)

* 空间复杂度：O(1)

* 代码实现：

  ```java
  public static void selectSort(int[] array){
  	for(int i = 0;i < array.length-1;i++){
          
          //无序区间：[0,array.length-i）
          //有序区间：[arrar.length-i,array.length)
          int max = 0;
          for(int j = 1; j < array.length-i;j++){
              if(array[j] > array[max]){
                  max = j;
              }
          }
          
          int temp = array[max];
          array[max] = array[array.length-1-i];
          array[array.length-1-i] = temp;
      }
  }
  ```

  

###



