# 数组与矩阵

- [1. 把数组中的 0 移到末尾]
- [2. 改变矩阵维度]
- [3. 找出数组中最长的连续 1]
- [4. 有序矩阵查找]
- [5. 有序矩阵的 Kth Element]
- [6. 一个数组元素在 [1, n\] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数]
- [7. 找出数组中重复的数，数组值在 [1, n\] 之间]
- [8. 数组相邻差值的个数]
- [9. 数组的度]
- [10. 对角元素相等的矩阵]
- [11. 嵌套数组]
- [12. 分隔数组]

<hr />

* 把数组中的 0 移到末尾

  * 题目描述：给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

  * 示例：

    ```
    输入: [0,1,0,3,12]
    输出: [1,3,12,0,0]
    ```

  * 分析：双指针

  ```java
  class Solution {
      public void moveZeroes(int[] nums) {
          int index = 0;
          for(int i = 0;i < nums.length;i++){
              if(nums[i] != 0){
                  nums[index++] = nums[i];
              }
          }
  
          for(int i = index;i < nums.length;i++){
              nums[i] = 0;
          }
      }
  }
  ```

<hr />

* 改变矩阵维度

  * 题目描述:

    在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。

    给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。

    重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。

    如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。

  * 示例:

    ```
    输入: 
    nums = 
    [[1,2],
     [3,4]]
    r = 1, c = 4
    输出: 
    [[1,2,3,4]]
    解释:
    行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。
    ```

  * 分析:

  ```javascript
  class Solution {
      public int[][] matrixReshape(int[][] nums, int r, int c) {
          int[][] newNums = new int[r][c];
          
          if (nums.length == 0 || r * c != nums.length * nums[0].length)
              return nums;
              
          int index = 0;
  
          for(int i = 0;i < nums.length;i++){
              for(int j = 0; j < nums[0].length;j++){
                  newNums[index/c][index%c] = nums[i][j];
                  index++;
              }
          }
  
          return newNums;
      }
  }
  ```

  

<hr />

* 找出数组中最长的连续 1

  * 题目描述:给定一个二进制数组， 计算其中最大连续1的个数。

  * 示例:

    ```
    输入: [1,1,0,1,1,1]
    输出: 3
    解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.
    ```

  * 分析:

  ```java
  class Solution {
      public int findMaxConsecutiveOnes(int[] nums) {
          int max = 0;
          int count = 0;
  
          for(int i = 0;i < nums.length;i++){
              if(nums[i] == 1){
                  count++;
                  if(count > max){
                      max = count;
                  }
              }else{
                  count = 0;
              }
          }
  
          return max;
      }
  }
  ```

  

<hr />

* 有序矩阵查找

  * 题目描述:

    编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：

    ​	每行的元素从左到右升序排列。
    ​	每列的元素从上到下升序排列。

  * 示例:

    ```
    [
      [1,   4,  7, 11, 15],
      [3,   6,  9, 16, 22],
      [10, 13, 14, 17, 24],
      [18, 21, 23, 26, 30]
    ]
    给定 target = 5，返回 true。
    
    给定 target = 20，返回 false。
    ```

  * 分析:

    ```java
    class Solution {
        public boolean searchMatrix(int[][] matrix, int target) {
            if(matrix == null || matrix.length == 0){
                return false;
            }
            int row = 0;
            int col = matrix[0].length-1;
    
            int rowLength = matrix.length-1;
            int colLength = matrix[0].length-1;
    
            while(row <= rowLength && col >= 0){
                int num = matrix[row][col];
                if(num == target){
                    return true;
                }else if(num > target){
                    col--;
                }else{
                    //num < target
                    row++;
                }
            }
    
            return false;
        }
    }
    ```

    

* 有序矩阵的 Kth Element

  * 题目描述:给定一个 *n x n* 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。
    请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。

  * 示例:

    ```
    matrix = [
       [ 1,  5,  9],
       [10, 11, 13],
       [12, 13, 15]
    ],
    k = 8,
    
    返回 13。
    ```

  * 分析:大顶堆

  ```java
  class Solution {
      public int kthSmallest(int[][] matrix, int k) {
          PriorityQueue<Integer> queue = new PriorityQueue<Integer>(new Comparator<Integer>() {
              @Override
              public int compare(Integer o1, Integer o2) {
                  return o2-o1;
              }
          });
  
          for(int i = 0;i < matrix.length;i++){
              for(int j = 0;j < matrix[0].length;j++){
                  queue.add(matrix[i][j]);
                  if(queue.size() > k){
                      queue.poll();
                  }
              }
          }
  
          return queue.peek();
      }
  }
  ```

  

