# 链表

1. 相交链表 （*）
2. 反转链表 （*）
3. 归并两个有序链表
4. 从有序链表中删除重复节点Ⅰ
5. 从有序链表中删除重复节点Ⅱ
6. 删除链表的倒数第n个节点
7. 交换链表中的相邻节点
8. 链表求和
9. 回文链表
10. 分隔链表
11. 链表元素按奇偶聚集

<hr color=red />

* 相交链表

  * 题目描述：编写一个程序，找到两个单链表相交的起始节点。

  * 分析：两个单链表相交结果肯定是Y形的，不会是X形的

    我的思路：求出两个链表的长度lenA,lenB，让长的那条先走abs(lenA-lenB)步，然后让两个同步出发，直到节点相等。

    ```java
    public class Solution {
        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
            ListNode newHead = null;
            if(null == headA||null == headB){
                return newHead;
            }
    
            int lenA = listLength(headA);
            int lenB = listLength(headB);
    
            if(lenA > lenB){
                while(lenA - lenB > 0){
                    headA = headA.next;
                    lenA--;
                }
            }else if(lenA < lenB){
                while(lenB - lenA > 0){
                    headB = headB.next;
                    lenB--;
                }
            }
    
            while(headA != headB){
                headA = headA.next;
                headB = headB.next;
            }
    
            newHead = headA;
            return newHead;
        }
    
        //求得单链表的长度
        public static int listLength(ListNode head){
            int res = 0;
    
            while(null != head){
                res++;
                head = head.next;
            }
    
            return res;
        }
    }
    ```

  <hr />

* 反转链表

  * 题目描述：反转一个单链表。

  * 分析：利用一个节点的前驱，后继与本节点相互转换;简单来说就是前边后，后变前。**不对这都不用说大家都懂得**

    ```java
    class Solution {
        public ListNode reverseList(ListNode head) {
            if(null == head) return null;
    
            ListNode cur = head; //当前节点
            ListNode prev = null; //前驱节点：注意这里一定要设置为null,因为我们转换后让当前节点的前驱变成了后继，反转后最后一个节点的后继为null
            ListNode newHead = null; //指向反转后链表的头结点
            
            while(null != cur){
                ListNode postNode = cur.next; //后继节点
    
                if(null == postNode){ //最后一个节点
                    newHead = cur;
                }
    
                cur.next = prev;
                prev = cur;
                cur = postNode;
            }
    
            return newHead;
        }
    }
    ```

  <hr />

* 归并两个有序链表

  * 题目描述：将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

  * 分析：逐个比较，相比小的进入新链表；

    ```java
    class Solution {
        public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
            if(null == l1) return l2;
            if(null == l2) return l1;
    		
            //创建带头结点的链表；方便操作
            ListNode newHead = new ListNode(-1);
            ListNode cur = newHead;
            
            while(null != l1 && null != l2){
                if(l1.val < l2.val){
                    cur.next = l1;
                    l1 = l1.next;
                }else{
                    cur.next = l2;
                    l2 = l2.next;
                }
                cur = cur.next;
            }
    
            if(l1 != null){ 
                cur.next = l1;
            }
    
            if(l2 != null){
                cur.next = l2;
            }
    
            return newHead.next;
        }
    }
    ```

    

* 从有序链表中删除重复节点Ⅰ

  * 题目描述：

* 从有序链表中删除重复节点Ⅱ

  * 题目描述：

* 删除链表的倒数第n个节点

  * 题目描述：

* 交换链表中的相邻节点

  * 题目描述：

* 链表求和

  * 题目描述：

* 回文链表

  * 题目描述：

* 分隔链表

  * 题目描述：

* 链表元素按奇偶聚集

  * 题目描述：