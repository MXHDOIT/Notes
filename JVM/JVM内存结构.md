# JVM内存结构

* 内存模型
* Java堆
* Java虚拟机栈
* 本地方法栈
* 方法区
* 程序计数器
* 直接内存



### 内存模型

* Java虚拟机在运行Java程序时，会管理着一块内存区域：运行时数据区
* 在运行行数据区里，会根据用途进行划分：
  1. Java虚拟机栈(栈区)
  2. 本地方法栈
  3. Java堆
  4. 方法区
  5. 程序计数器

![image-20200417151035248](E:\GitHub\picBed\img\image-20200417151035248.png)





### Java堆

* 定义：堆内存，是垃圾收集器管理的主要区域，因此也称：GC堆
* 作用：存放Java对象实例
* 特点：
  * jvm内存中最大
  * 线程共享
* 抛出的异常：
  * OutOfMemoryError异常：堆中没有足够的内存完成对象实例的分配&堆无法再扩展
* 说明：
  * 从内存回收的角度  分为：新生代&老年代
  * 从内存分配的角度   相当于：多个线程私有的分配缓冲区
* 内含：
  * 字符串常量池：**下面与运行常量池对比介绍**



### Java虚拟机栈

* 定义：栈内存，是Stack，Java方法执行的内存模型
* 作用：存储java方法执行时的局部变量
  * 说明：以栈帧的形式；含数据类型，对象的引用；方法执行结束后则释放。
* 特点：
  * 线程私有
  * 生命周期与线程相同
* 抛出的异常：
  * OutOfMemoryError异常：虚拟机栈扩展时无法申请到内存空间
  * StackOverflowError异常：线程请求栈深度>虚拟机所允许深度
* 说明：
  * 每个java方法执行时都会创建一个栈帧
  * 一个java方法从被调用到执行完成 = 一个栈帧在虚拟机栈中的入栈到出栈
  * 局部变量表所需内存空间在方法编译时就会完成分配，在方法运行时不会改变大小



### 本地方法栈

* 说明：十分类似`Java`虚拟机栈，与Java虚拟机区别在于：服务对象，即Java虚拟机栈为执行  `Java`方法服务；本地方法栈为执行  `Native`方法服务



### 方法区

* 定义：堆的一个逻辑部分；为了与java堆区分，又称“非堆”区域
* 作用：存储已被虚拟机加载的类信息，常量，静态变量等数据
* 特点：线程共享
* 抛出的异常：
  * OutOfMemoryError异常：当方法区无法满足内存分配需求
* 说明：
  * 该区域的内存回收主要针对运行时常量池和对类的卸载
  * 又称永生代：回收条件苛刻，很少出现垃圾收集
* 内含
  * 运行常量池：**下面与字符串常量池对比介绍**

### 程序计数器

* 定义：当前线程所执行的字节码的行号指示器
* 作用：实现异常处理，线程恢复等基础功能
* 原理：通过改变计数器的值来选取下一条执行的字节码指令
* 特点：
  * 线程私有
  * 内存空间小
* 抛出的异常：无
* 说明：
  * 线程私有的内存区域：为了使得线程切换后恢复到正确的执行位置，每条线程都配有一个独立的程序计数器，各线程互不影响，独立存储的内存区域

### 直接内存

* 定义：NIO类（`JDK`1.4引入）中基于通道和缓冲区的`I/O`方式 通过使用`Native`函数库 直接分配 的堆外内存

* 特点：不受堆大小限制

* 应用场景：适用于频繁调用的场景

  通过一个 存储在`Java`堆中的`DirectByteBuffer`对象 作为这块内存的引用 进行操作，从而避免在`Java` 堆和 `Native`堆之间来回复制数据，提高使用性能

* 抛出的异常：`OutOfMemoryError`，即与其他内存区域的总和 大于 物理内存限制

# Java字符串常量池，class常量池和运行时常量池

### 字符串常量池（string pool）

* 字符串常量池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的）。string pool在每个HotSpot VM的实例只有一份，被所有的类共享。在jdk1.8后，将String常量池放到了堆中。

### class常量池

* 当java文件被编译成class文件之后，会在class文件中生成我们所说的class常量池，class文件中除了包含**类的版本、字段、方法、接口**等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种**字面量**(文本字符串、被声明为final的常量、基本数据类型的值)和**符号引用**(类和接口的全限定名、字段的名称和描述符、方法的名称和描述符)。
* **jvm的方法区里存放着类的版本，字段，方法，接口和常量池。常量池里存储着字面量和符号引用。**

![image-20200417233814020](E:\GitHub\picBed\img\image-20200417233814020.png)

### 运行时常量池

* 当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在上面我也说了，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询字符串常量池，也就是我们上面所说的string pool，以保证运行时常量池所引用的字符串与字符串常量池中所引用的是一致的。

### 相关概念

* ##### 方法区中的运行时常量池

  * 运行时常量池是方法区的一部分。
     CLass文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
     运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。

* **常量池的好处**

  * 常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。
     例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。
     （1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。
     （2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相。

    

  