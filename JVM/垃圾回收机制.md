### 对象被判定为垃圾的标准

- 没有被其他对象引用

<hr/>

### 判定对象是否为垃圾的算法

- 引用计数算法：则是通过判断一个对象的引用数量来决定对象是否可以被回收
  - 每个对象实例都有一个引用计数器，被引用就加1，完成引用就减1
  - 任何引用计数器为0的对象实例将会被当做垃圾收集
  - **优点**：执行效率高，程序执行影响小
  - **缺点**：会出现循环引用，导致内存泄漏
- 可达性分析算法：判断对象的引用链是否可达来决定对象时候可以回收
  - 以GC Roots做为根节点进行引用，当一个对象到GC Roots没有任何引用链相连时，则对象不可用。
  - 可以作为GC Root的对象：
- 虚拟机中引用的对象(栈帧中的本地变量表）
  - 方法区中的常量引用的对象
  - 方法区中类静态属性引用的对象
  - 本地方法栈中JNI(Native方法)的引用对象
  - 活跃线程的引用对象

<hr/>

### 垃圾回收算法

1. 标记-清除算法
   * 标记：从GC roots 根集合进行扫描，对存活的对象进行标记
   * 清除：然后对堆内存中线性遍历清除未标记的对象
   * **缺点：会产生碎片化的内存**

2. 复制算法
   * 分为两个区：对象面和空闲面
   * 对象在对象面上创建
   * 存活的对象被从对象面复制到空闲面
   * 将对象面多有对象进行清除
   * **优点：**
     * 解决碎片化问题
     * 顺序分配内存，简单高效
     * 适用于对象存活率低的场景

3. 标记-整理算法
   * 标记：从GC roots 根集合进行扫描，对存活的对象进行标记
   * 清除：移动所有存活的对象，且按照内存地址次序依次排列将末端内存地址以后的内存全部回收

<hr />

### 垃圾回收的过程

![image-20200629211823280](C:\Users\apple\AppData\Roaming\Typora\typora-user-images\image-20200629211823280.png)

**堆的GC：**

1. 新生代GC（Minor GC）：——Eden区和使用的S区，存活对象，复制到留空的S区。GC前后，两块S区的角色发生转变

   * Eden区：
     * 进入对象的条件，优先分配的区域——空间不足时，触发**Minor GC(新生代GC)**
   * Survivor区：一块保存对象，一块留空
     * 进入对象的条件：触发Minor GC时，留空的S区，会进入GC后存活对象——空间不足，导致

2. 老年代GC（Major GC）：——空间不足，触发Major GC(老年代GC)

   * 进入对象的条件：

     1. 大对象直接进入
     2. 长期存活的对象进入老年代——对象年龄>阈值
     3. Minor GC时，留空S区，会进入GC后存活对象，所有存活对象，进入老年代

     * 空间不足：触发Major GC

![image-20200630122713673](C:\Users\apple\AppData\Roaming\Typora\typora-user-images\image-20200630122713673.png)

<hr/>

### STW(Stop The World)：GC导致停止用户线程

* 原因：用户线程和GC线程并发，并行的执行，标记可回收的对象，在用户线程并发执行时，有可能重新有引用指向该对象
* GC：什么时候会STW
  * 新生代GC：都会STW——影响：因为Minor GC时间非常快，几乎忽略不计，影响很小
  * 老年代GC：根据阶段来看是否会STW——影响：非常大，(老年代空间大，需要回收的对象多，耗时也多)
* Full GC一般是指影响很大(STW),所以一般都包含Major GC,可能出现Minor GC

<hr />

### 垃圾收集器

* **垃圾收集器的指标：**

  1. 考虑内存区域：新生代【复制算法】，老年代【标记清除算法，标记整理算法】

  2. 吞吐量：用户体验

     ![image-20200630123610065](C:\Users\apple\AppData\Roaming\Typora\typora-user-images\image-20200630123610065.png)

     * 用户体验：指标为单次STW时间，越长用户体验越差，越短体验越好
     * 吞吐量：指标和STW总时间有关，越长吞吐量越低，越低吞吐量越好
     * 统计结果表示：
       1. 在固定时间内来计算，单次STW时间越长，STW总时间可能越少，反比关系
       2. 用户体验和吞吐量对应的表现出反比关系

* **JVM的运行模式**

  * Server：启动较慢，稳定后比Client快
  * Client：启动较快，

- **垃圾收集器之间的联系：**

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1522819/1591068525581-c6cdcc21-aa56-47c4-883e-e361598db108.png)

* **新生代收集器：**

  1. Serial：单线程，STW,复制算法
  2. ParNew：多线程，STW，复制算法----和CMS搭配使用在用户体验优先的程序中
  3. Parallel Scanvenge：
     1. 多线程，STW，复制算法
     2. 吞吐量优先：主要是后台任务型(比如定时任务，不涉及用户使用的程序)
     3. 自适应的调节策略：jvm设置这个参数=true之后，jvm可以监控性能，并动态的设置内存相关参数(如年龄阈值，新生代大小，Eden和S区比例)

* **老年代收集器：**

  1. Serial Old：单线程，标记整理算法--CMS在发生并发失败(Concurrent Mode Failure) 时作为备用垃圾回收

  2. Parallel Old：

     * 多线程，标记整理算法，STW
     * 吞吐量优先——搭配Parallel Scanvenge一起使用

  3. CMS(Concurrent Mark Sweep)

     1. 标记清楚算法

     2. 用户体验优先

     3. 分为四个阶段：

        1. 初始标记：标记GC Roots能直接关联的对象，速度很快，STW
        2. 并发标记：GC Roots Tracing
        3. 重新标记：STW
           * 解决第二阶段用户线程并发执行，导致已经标记的对象(之前可回收)被重新引用(有GC Roots变量指向该对象)
        4. 并发清除：并发清除对象

        * 四个阶段中：

          1. 1和3执行速度快，消耗时间少——暂停用户线程时间少
          2. 2和4，执行时间相对较慢，但是可以和用户线程并发执行

          总的来看，CMS垃圾回收的工作是和用户线程同时执行——CMS名称的由来

     4. 缺陷

        1. CMS垃圾回收线程会抢占CPU资源，导致用户线程总的执行时间更少
        2. 浮动垃圾问题：
           1. 产生原因：CMS第四个阶段，用户线程并发执行又可能导致有对象进入老年代，而老年代也可能剩余空间不足，触发Major GC——Concurrent Mode Failure
           2. 解决方案：使用Serial Old来进行垃圾回收
           3. 标记清除算法会导致老年代空间碎片，如果进入的对象没有连续的空用空间，触发Full GC

* 全堆的垃圾收集器

  1. 整体看基于标记整理算法，局部看基于复制算法
  2. 用户体验优先
  3. 内存划分：堆内存划分为很多region，每个region都是动态指定为Eden区，S区，T区(老年代内存)
  4. 原理/实现：分为4个阶段
     1. 初始标记：可以和Minor GC(新生代GC)，同时执行，STW
     2. 并发标记：Garbagec First,清理老年代总(T区，Tenured Generation)，存活率很小或没有对象存活的T区
     3. 最终标记：STW,和CMS第三个阶段算法不同
     4. 筛选回收：因为和CMS算法不同，采取clean up/copy和新生代类似的整理工作。可以和Minor GC同时执行，STW

## 面试题

- Java中的强引用，软引用，弱引用，虚引用有什么用？
- 