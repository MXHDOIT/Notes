# 索引

### 概念

* 索引是用来提高数据库**查询效率**的一种方式。**建立有效、合适**的索引可以极大地提高查询效率，是数据库高性能优化操作必做的一件事。索引通俗地讲就像书籍的目录一样，它对数据库表也维护一套目录，通过目录可以快速地定位到要查询的数据，而不用把整个数据库表都扫描一遍，所以索引是提高SQL语句查询效率的一种有效手段。

### 索引分类

* 普通索引：这是**最基本**的索引，它没有任何限制
* 主键索引：它是一种特殊的**唯一索引，不允许有空值**。一般是在建表的时候同时创建主键索引
* 唯一索引：它与前面的普通索引类似，不同的就是：索引列的值**必须唯一**，但**允许有空值**。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：
* 组合索引：一个组合索引包含**两个或两个以上的列**
* 全文索引：对文本的**内容进行分词**，进行搜索
  * 假设字段的数据类型是长文本，文本字段上(text等)建立了普通索引，我们需要查找关键字的话，那么其条件只能是where column like '%xxxx%' ，但是，这样做就会让索引失效，这时就需要全文索引了。

### 创建索引

* 普通索引：
  * 建表时：INDEX IndexName(`字段名`(length))
  * 建表后：CREATE INDEX IndexName ON `TableName`(`字段名`(length)) 或 ALTER TABLE TableName ADD INDEX IndexName(`字段名`(length)
*  唯一索引：
  * 建表时：UNIQUE INDEX IndexName(`字段名`(length)) 
  * 建表后：CREATE UNIQUE  INDEX IndexName ON `TableName`(`字段名`(length)) 或 ALTER TABLE TableName ADD UNIQUE  INDEX IndexName(`字段名`(length)）
* 主键索引：
  * 一般在建表的时候自动创建，主键一般会设为 int 而且是 AUTO_INCREMENT自增类型的
* 全文索引：
  * 建表时：FULLTEXT INDEX IndexName(`字段名`(length)) 
  * 建表后：CREATE FULLTEXT  INDEX IndexName ON `TableName`(`字段名`(length)) 或ALTER TABLE TableName ADD FULLTEXT  INDEX IndexName(`字段名`(length)）
* 组合索引：
  * 建表时：INDEX IndexName(`字段名`(length)，`字段名`(length)，........) 
  * 建表后：CREATE INDEX IndexName ON `TableName`(`字段名`(length)，`字段名`(length)，........)  或 ALTER TABLE TableName ADD INDEX IndexName(`字段名`(length)，`字段名`(length)，........) 

**索引的删除：**DORP INDEX IndexName ON `TableName`

### 索引不能使用

1. 使用不等于（<>、!=、NOT IN）操作符进行条件判断时是不能使用索引的
2. 使用前导模糊查询（%xx%）不能使用索引，但是后导模糊查询（xx%）是可以使用索引的
3. 比较不匹配的数据类型是指某一列在比较查询时，假如列是varchar字符串类型，但是在赋值的时候赋值int整型，这时这一列即使有索引，也不会使用到索引
4. 重复性高的字段**不适合做索引**

### 索引的利弊及建立原则

* 优势：
  1. 索引最大的一个优势就是提高查询效率，它可以通过创建唯一索引或者主键索引来标识行的唯一性，在查询的时候可以快速定位到要查询的行数据。
  2. 可以加快表与表之间的连接查询。
  3. 在分组和排序的时候可以极大地节省时间，使用索引可以进行快速排序，分组查询时虽然不能直接使用索引，但是分组查询要先进行排序，而在排序这个阶段就会减少时间，所以分组查询也能节省时间。
  4. 使用索引来进行查询、排序、分组，使用优化隐藏器提高系统的性能。
* 劣势：
  1. 创建索引和维护索引需要耗费时间，随着数据量的增大时间也会逐渐增加。
  2. 索引文件的大小会逐渐增大，索引文件需要占用物理空间，如果建立聚簇索引，文件大小会更大，会使数据库的存储逐渐变大。
  3. 对表进行增加、修改、删除的时候，都需要对索引进行维护，这会影响对表和数据的操作速度，延长对表的操作时间

### 索引的数据结构(为什么)

* 对于MySQL来说，在服务器层并不实现索引，而是交给存储引擎来实现的，因此不同的存储引擎实现的索引类型不太一样。**InnoDB**作为当前使用最为广泛的存储引擎，使用的是**B+树索引**，因此我们大部分时间提到的索引也都是指的它。

* MySQL主要有以下几种索引：

  * B-树索引/B+树索引
  * 哈希索引
  * 空间数据索引
  * 全文索引

* B-树

  * B-树是一棵多路平衡查找树,对于一棵M阶的B-树有以下的性质:

    * 根节点至少有两个子女.

    * 每个节点包含k-1个元素和k个孩子,其中m/2 <= k <= m.

    * 每一个叶子节点都包含k-1个元素,其中m/2 <= k <= m.

    * 所有的叶子节点位于同一层.

    * 每个节点中的元素从小到大排列,那么k-1个元素正好是k个孩子包含的值域的划分.

      这么说可能会有一些难理解,可以将B-树理解为一棵更加**矮胖的二叉搜索树.**

* B+树

  * B+树是B-树的进阶版本,在B-树的基础上又做了如下的限制:
    * 每个中间节点不保存数据,只用来索引,也就意味着所有非叶子节点的值都被保存了一份在叶子节点中.
    * 叶子节点之间根据自身的顺序进行了链接.
  * 这样可以带来什么好处呢?
    * 中间节点不保存数据,那么就可以保存更多的索引,减少数据库磁盘IO的次数.
    * 因为中间节点不保存数据,所以每一次的查找都会命中到叶子节点,而叶子节点是处在同一层的,因此查询的性能更加的稳定.
    * 所有的叶子节点按顺序链接成了链表,因此可以方便的话进行范围查询.

#### 为什么使用B-树或B+树？

* MySQL索引是用来提高查询速度的。为了提高查询速度，需要有一个高效的算法和数据结构，而如果按**顺序**来查找某个数据，当数据量很大的时候，显然**查询速度很慢**。除了按顺序查找，也可以使用**二分法**来查找，但是二分法**要求数据是有序**的。另外，还可以使用**二叉树**方式来查找数据，但是它的**叶子节点最多有两个，查询速度也会变慢**。数据库常用数据结构B-Tree和B+Tree来构建数据库索引，MySQL数据库使用的就是**B+Tree**数据结构。

  

  

  

  

  

  

  

  

  

  