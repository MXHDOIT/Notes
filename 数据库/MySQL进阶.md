# MySQL进阶

### 1.视图

* 视图是一条SELECT语句返回的结果集，这个结果集可以从一张表中查询出来，也可以从多张表中查询出来。SELECT语句使用的表可以当成基本表，而结果集则构成一张虚拟表。虚拟表也是表，可以进行增、删、改、查操作，但是有条件限制，它可以存放SELECT语句查询的结果，但是不存放具体数据，基本表里的数据变化会影响视图虚拟表查询的结果。
* 视图的好处在于方便查询，只查询出想要的字段。假如有三张表，每张表有两个字段是需要作为返回结果的，这时可以创建一个视图，把这三张表的两个字段都放在视图虚拟表中，查询的时候直接查询视图，可以获取到这三张表的两个字段数据，方便SQL语句查询，减少复杂的SQL语句，增强可读性。同时，使用视图也更加安全，基本表查询不能限定特定的列和行，而有不想显示出来的存在敏感信息的列时，视图对其可以灵活地控制。

### 2.游标

* 在MySQL数据库查询中，可以使用SELECT语句将满足条件的数据一起查询出来，但是没有办法一行一行地获取数据并做一些复杂的处理。如满足条件的有10条语句，那么使用SELECT语句就一起查询出10条，而获取一行之后接着处理一行数据SELECT语句是做不到的，这时游标就有了用武之地。游标是一个存储在MySQL数据库里用来查询的对象，它可以每次从结果集里获取一行数据，进行相应的处理。有了游标，就可以滚动查询满足条件的数据，可以做一些复杂的处理。MySQL游标只能用于存储过程或者函数中。

### 3.触发器

* 触发器是一种与表有关的操作对象，当表上出现指定事件（INSERT、UPDATE、DELETE）时，会调用触发器对象，执行触发器的操作，如在主表上执行删除语句，可以调用触发器执行删除子表语句，以达到级联删除的效果

## 4.索引

* 索引是用来提高数据库查询效率的一种方式。建立有效、合适的索引可以极大地提高查询效率，是数据库高性能优化操作必做的一件事。索引通俗地讲就像书籍的目录一样，它对数据库表也维护一套目录，通过目录可以快速地定位到要查询的数据，而不用把整个数据库表都扫描一遍，所以索引是提高SQL语句查询效率的一种有效手段。

### 4.1 索引的数据结构

* MySQL索引是用来提高查询速度的。为了提高查询速度，需要有一个高效的算法和数据结构，而如果按顺序来查找某个数据，当数据量很大的时候，显然查询速度很慢。除了按顺序查找，也可以使用二分法来查找，但是二分法要求数据是有序的。另外，还可以使用二叉树方式来查找数据，但是它的叶子节点最多有两个，查询速度也会变慢。数据库常用数据结构B-Tree和B+Tree来构建数据库索引，MySQL数据库使用的就是B+Tree数据结构。

### 4.2 索引不能使用

1. 使用不等于（<>、!=）操作符进行条件判断时是不能使用索引的
2. 使用前导模糊查询（%xx%）不能使用索引，但是后导模糊查询（xx%）是可以使用索引的
3. 比较不匹配的数据类型是指某一列在比较查询时，假如列是varchar字符串类型，但是在赋值的时候赋值int整型，这时这一列即使有索引，也不会使用到索引。

### 4.3 索引的利弊及建立原则

* 优势：
  1. 索引最大的一个优势就是提高查询效率，它可以通过创建唯一索引或者主键索引来标识行的唯一性，在查询的时候可以快速定位到要查询的行数据。
  2. 可以加快表与表之间的连接查询。
  3. 在分组和排序的时候可以极大地节省时间，使用索引可以进行快速排序，分组查询时虽然不能直接使用索引，但是分组查询要先进行排序，而在排序这个阶段就会减少时间，所以分组查询也能节省时间。
  4. 使用索引来进行查询、排序、分组，使用优化隐藏器提高系统的性能。
* 劣势：
  1. 创建索引和维护索引需要耗费时间，随着数据量的增大时间也会逐渐增加。
  2. 索引文件的大小会逐渐增大，索引文件需要占用物理空间，如果建立聚簇索引，文件大小会更大，会使数据库的存储逐渐变大。
  3. 对表进行增加、修改、删除的时候，都需要对索引进行维护，这会影响对表和数据的操作速度，延长对表的操作时间
* 索引的建立原则如下。
  1. 主键的字段需要建立唯一索引或者主键索引。
  2. 用于连接查询的字段（外键）可以建立索引。
  3. 经常用来排序的字段可以建立索引。
  4. 频繁使用WHERE的条件字段可以建立索引。
  5. 唯一性太差的字段不适合建立索引。
  6. 更新频率远大于查询的字段不适合建立索引。
  7. 不会出现WHERE条件表达式的字段不适合建立索引。
  8. 对于类型为text、blob、image、bit的字段，不适合建立索引。

###  5.事务

 - 概念：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。
 - 操作：

   	1. 开启事务：start transaction;
      	2. 回滚：rollback;
   	3. 提交：commit;

 - MySQL数据库中事务默认自动提交

  *  事务提交的两种方式：
       *   自动提交：
            *  mysql就是自动提交的
            *  一条DML(增删改)语句会自动提交一次事务。
       *  手动提交：
            *  Oracle 数据库默认是手动提交事务
          *  需要先开启事务，再提交
       *  修改事务的默认提交方式：		* 
          * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交
          * 修改默认提交方式： set @@autocommit = 0;

 - 事务的四大特征：
   1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。
   2. 一致性：事务操作前后，数据总量不变
   3. 隔离性：多个事务之间。相互独立。
   4. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。

 -  事务的隔离级别（了解）：[https://blog.csdn.net/djy_2017/article/details/104561930?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159219906319195265925598%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=159219906319195265925598&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-104561930.pc_search_back_js&utm_term=%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB](https://blog.csdn.net/djy_2017/article/details/104561930?ops_request_misc=%7B%22request%5Fid%22%3A%22159219906319195265925598%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=159219906319195265925598&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-104561930.pc_search_back_js&utm_term=事务隔离级别)
    * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。
    * 存在问题：
      1. 脏读：一个事务，读取到另一个事务中没有提交的数据
      2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。
      3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。
    * 隔离级别：
      1. read uncommitted：读未提交
         * 产生的问题：脏读、不可重复读、幻读
      2. read committed：读已提交 （Oracle）
         * 产生的问题：不可重复读、幻读
      3. repeatable read：可重复读 （MySQL默认）
         * 产生的问题：幻读
      4. serializable：串行化【类似于线程中的锁机制】
         * 可以解决所有的问题

    * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低
    * 数据库查询隔离级别：
      * select @@tx_isolation;
    * 数据库设置隔离级别：
      * set global transaction isolation level  级别字符串;